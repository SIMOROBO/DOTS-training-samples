#ifndef COMMONPARTICLECOMPUTESHADER_INCLUDED
#define COMMONPARTICLECOMPUTESHADER_INCLUDED

#define KERNEL_SIZE 4

#define GOLDENRATIO 0.618033988749895
#define PI 3.1415926535897932384626433
#define LARGE_FLOAT_VALUE 9999999.9

struct FixedUpdateData
{
    float3 position;
    float3 velocity;
    float3 color;
};

struct SimOutput
{
    float3 normal;
    float dist;
};

RWStructuredBuffer<float4x4> TransformsBuffer;
RWStructuredBuffer<FixedUpdateData> FixedUpdateBuffer;

uint gInstancesCount;
uint gInstancesPerRow;
float gTime;
uint gChunksPerRow;

float gAttraction;
float gJitter;
float gInteriorColorDist;
float gExteriorColorDist;
float gColorStiffness;
float gSpeedStretch;
float4 gSurfaceColor;
float4 gInteriorColor;
float4 gExteriorColor;

uint GetParticleIndex(uint3 groupId, uint groupIndex)
{
    uint chunkSize = KERNEL_SIZE * KERNEL_SIZE * KERNEL_SIZE;
    uint gridSliceSize = chunkSize * gChunksPerRow * gChunksPerRow;
    uint gridLineSize = chunkSize * gChunksPerRow;

    uint threadGroupIndex = (groupId.x * gridSliceSize) + groupId.y * gridLineSize + (groupId.z * chunkSize);
    uint index = threadGroupIndex + groupIndex;
    return index;
}

float3 safenormalize(float3 v)
{
    return normalize(v == 0 ? float3(0, 1, 0) : v);
}

float SmoothMin(float a, float b, float radius)
{
    float e = max(radius - abs(a - b), 0);
    return min(a, b) - e * e * 0.25f / radius;
}

float Sphere(float3 pos, float radius)
{
    return sqrt(dot(pos, pos)) - radius;
}

float rand_1_05(float2 uv)
{
    float2 noise = frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453);

    return abs(noise.x + noise.y) * 0.5;
}

float rand_float(float2 uv)
{
    return rand_1_05(uv);
}

float3 rand_dir(float2 uv)
{
    float2 uv2 = float2(uv.x + GOLDENRATIO, uv.y + GOLDENRATIO);
    float2 uv3 = float2(uv.x + 2.0 * GOLDENRATIO, uv.y + 2.0 * GOLDENRATIO);
    float3 dir = float3(rand_float(uv) * 2.0f - 1.0f, rand_float(uv2) * 2.0f - 1.0f, rand_float(uv3) * 2.0f - 1.0f);

    return safenormalize(dir);
}

FixedUpdateData ComputeParticleData(int index, float3 normal, float dist)
{
    FixedUpdateData data = FixedUpdateBuffer[index];
    float3 position = data.position;
    float3 velocity = data.velocity;
    float3 color = data.color;

    velocity -= safenormalize(normal) * gAttraction * clamp(dist, -1.0f, 1.0f);
    velocity += rand_dir(float2(index, gTime)) * rand_float(float2(index, gTime + 1.0f)) * gJitter;
    velocity *= 0.99f;
    position += velocity;

    float3 targetColor;
    if (dist > 0.0f)
    {
        targetColor = lerp(gSurfaceColor.xyz, gExteriorColor.xyz, dist / gExteriorColorDist);
    }
    else
    {
        targetColor = lerp(gSurfaceColor.xyz, gInteriorColor.xyz, -dist / gInteriorColorDist);
    }
    color = lerp(color, targetColor, 0.02 * gColorStiffness);

    data.position = position;
    data.velocity = velocity;
    data.color = color;

    return data;
}

float4x4 LookAtMatrix(float3 target)
{
    float3 eye = 0;
    float3 up = float3(0, 1, 0);
    float3 zAxis = normalize(target - eye);
    float3 xAxis = normalize(cross(up, zAxis));
    float3 yAxis = cross(zAxis, xAxis);

    return float4x4(
            float4(xAxis.x, yAxis.x, zAxis.x, 0),
            float4(xAxis.y, yAxis.y, zAxis.y, 0),
            float4(xAxis.z, yAxis.z, zAxis.z, 0),
            float4(-dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1)
        );
}

float4x4 LookAtTRSC(float3 position, float3 directionNormalized, float3 scale, float3 color)
{
    float3 up = float3(0, 1, 0);
    float3 zAxis = directionNormalized;
    float3 xAxis = normalize(cross(up, zAxis));
    float3 yAxis = cross(zAxis, xAxis);

    return float4x4(
            float4(xAxis.x * scale.x, yAxis.x * scale.y, zAxis.x * scale.z, position.x),
            float4(xAxis.y * scale.x, yAxis.y * scale.y, zAxis.y * scale.z, position.y),
            float4(xAxis.z * scale.x, yAxis.z * scale.y, zAxis.z * scale.z, position.z),
            float4(color.x, color.y, color.z, 1)
        );
}

float4x4 BuildCustomMatrix(float3 position, float3 directionNormalized, float scaleZ, float3 color)
{
    float3 up = float3(0, 1, 0);
    float3 zAxis = directionNormalized;
    float3 xAxis = normalize(cross(up, zAxis));
    float3 yAxis = cross(zAxis, xAxis);

    return float4x4(
            float4(xAxis.x, yAxis.x, zAxis.x, position.x),
            float4(xAxis.y, yAxis.y, zAxis.y, position.y),
            float4(xAxis.z, yAxis.z, zAxis.z, position.z),
            float4(color.x, color.y, color.z, scaleZ)
        );
}

#endif
